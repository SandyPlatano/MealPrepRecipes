/**
 * Shopping List Markdown Generator
 *
 * Generates GitHub Flavored Markdown exports for shopping lists
 * with checkboxes grouped by ingredient category.
 */

import {
  type IngredientCategory,
  CATEGORY_ORDER,
  groupIngredientsByCategory,
} from "@/lib/utils/categorize-ingredient";
import {
  createMarkdownHeading,
  createMarkdownCheckboxList,
  createMarkdownHorizontalRule,
  italic,
  joinSections,
  downloadMarkdownFile,
  formatDateRangeForFilename,
} from "./markdown-generator";

/**
 * Shopping list item for markdown export
 */
export interface ShoppingListItem {
  ingredient: string;
  recipeTitle?: string;
}

export interface ShoppingListMarkdownOptions {
  weekRange: string;
  items: ShoppingListItem[];
  includeRecipeSources?: boolean;
}

/**
 * Generate complete markdown document for a shopping list
 */
export function generateShoppingListMarkdown(
  options: ShoppingListMarkdownOptions
): string {
  const { weekRange, items, includeRecipeSources = false } = options;
  const sections: string[] = [];

  // Title
  sections.push(createMarkdownHeading(`Shopping List: ${weekRange}`, 1));

  // Stats line
  const uniqueIngredients = new Set(items.map((i) => i.ingredient));
  sections.push(italic(`${uniqueIngredients.size} items`));

  // Extract all ingredients
  const ingredients = items.map((item) => item.ingredient);

  // Group by category
  const grouped = groupIngredientsByCategory(ingredients);

  // Generate sections for each category with items
  const categorySections = formatCategorizedList(grouped, includeRecipeSources ? items : undefined);
  if (categorySections) {
    sections.push(categorySections);
  }

  // Footer
  sections.push(
    joinSections(
      createMarkdownHorizontalRule(),
      italic("Generated by MealPrepRecipes")
    )
  );

  return joinSections(...sections);
}

/**
 * Format categorized shopping list with checkboxes
 */
function formatCategorizedList(
  grouped: Record<IngredientCategory, string[]>,
  items?: ShoppingListItem[]
): string | null {
  const sections: string[] = [];

  // Build a map of ingredient to recipe sources if provided
  const ingredientSources = new Map<string, Set<string>>();
  if (items) {
    items.forEach((item) => {
      if (item.recipeTitle) {
        const existing = ingredientSources.get(item.ingredient) || new Set();
        existing.add(item.recipeTitle);
        ingredientSources.set(item.ingredient, existing);
      }
    });
  }

  // Process categories in order
  CATEGORY_ORDER.forEach((category) => {
    const categoryItems = grouped[category];
    if (categoryItems.length === 0) return;

    // Category heading
    sections.push(createMarkdownHeading(category, 2));

    // Format items with optional source annotations
    const formattedItems = categoryItems.map((ing) => {
      const sources = ingredientSources.get(ing);
      if (sources && sources.size > 0) {
        return `${ing} *(${Array.from(sources).join(", ")})*`;
      }
      return ing;
    });

    // Checkbox list
    sections.push(createMarkdownCheckboxList(formattedItems));
  });

  if (sections.length === 0) return null;
  return joinSections(...sections);
}

/**
 * Generate shopping list from raw ingredients array (simpler interface)
 */
export function generateSimpleShoppingListMarkdown(
  weekRange: string,
  ingredients: string[]
): string {
  const items: ShoppingListItem[] = ingredients.map((ing) => ({
    ingredient: ing,
  }));
  return generateShoppingListMarkdown({ weekRange, items });
}

/**
 * Generate filename for shopping list export
 */
export function generateShoppingListFilename(weekRange: string): string {
  const slug = formatDateRangeForFilename(weekRange);
  return `shopping-list-${slug}.md`;
}

/**
 * Export and download a shopping list as markdown
 */
export function downloadShoppingListAsMarkdown(
  options: ShoppingListMarkdownOptions
): void {
  const content = generateShoppingListMarkdown(options);
  const filename = generateShoppingListFilename(options.weekRange);
  downloadMarkdownFile(content, filename);
}
